{
    "name": "FishermansAssistant",
    "type": "directory",
    "children": [
        {
            "name": "api.js",
            "type": "file",
            "size": 7377,
            "modified": "Sun Mar 23 11:30:18 2025",
            "content": "import axios from 'axios';\nimport { OPENAI_API_KEY } from '@env';\n\nconst getSpeciesPrompt = (cityState) => `\nGiven a location in ${cityState} (e.g., \"Mobile, AL\"), provide a list of 5-10 popular fish species that anglers commonly target in this region. Return the list in the following JSON format:\n{\n  \"species\": [\n    \"Fish Species 1\",\n    \"Fish Species 2\",\n    \"Fish Species 3\",\n    ...\n  ]\n}\nUse current knowledge of recreational fishing in the United States or Canada for accuracy. Return only common names of species (e.g., \"Largemouth Bass,\" not \"Micropterus salmoides\"). Strictly return the response as JSON only, with no additional text or Markdown formatting outside the JSON structure.\n`;\n\nconst getAdvicePrompt = (location, species, cityState, currentDate, forecastData, waterData, speciesTempRange) => `\nYou are an expert fishing advisor providing tailored advice for anglers near ${cityState} on ${currentDate}. ${\n  location && location.coords ? `The coordinates are latitude ${location.coords.latitude}, longitude ${location.coords.longitude}, influencing local weather and water conditions.` : ''\n}\n\n**Current Conditions:**\n- **Air Temperature**: Low ${forecastData.lowTempF}\u00b0F, High ${forecastData.highTempF}\u00b0F\n- **Precipitation**: ${forecastData.totalPrecipIn} inches\n- **Wind Speed**: ${forecastData.avgWindMph} mph, direction ${forecastData.windDeg}\u00b0\n- **Barometric Pressure**: ${forecastData.pressureHpa} hPa\n- **Moon Phase**: ${forecastData.moonPhase} (0 = new, 0.5 = full, etc.)\n- **Water Temperature**: ${waterData.waterTempF ? `${waterData.waterTempF}\u00b0F` : 'Not available'}\n- **Water Level**: ${waterData.gageHeightFt ? `${waterData.gageHeightFt} ft` : 'Not available'}\n- **Optimal Water Temp for ${species || 'the species'}:**: ${speciesTempRange ? `${speciesTempRange.min}\u00b0F - ${speciesTempRange.max}\u00b0F` : 'Not available'}\n\n${\n  species && species !== 'None'\n    ? `Provide the best strategies to target ${species} under these conditions near ${cityState}. You MUST:\n      - Use all provided weather, water data, and optimal temperature range to tailor bait and strategy.\n      - Do not specify a particular fishing spot, but base tips on conditions typical within 30 miles of ${cityState}.`\n    : `Suggest ONE fish species to target (common name only) and the best strategies to catch it under these conditions near ${cityState}. You MUST:\n      - Use all provided weather, water data, and optimal temperature range to tailor bait and strategy.\n      - Do not specify a particular fishing spot, but base tips on conditions typical within 30 miles of ${cityState}.`\n}\n\n**Instructions:**\n- Use U.S. units (\u00b0F, inches, mph, feet, hPa).\n- Base tips on air temp, precipitation, wind, pressure, moon phase, water temp, water level, and the species' optimal water temperature range.\n- Avoid naming a specific location (e.g., \"Mobile Bay\"); focus on general strategies for the area.\n\nReturn the response in this JSON format:\n{\n  \"bait\": \"Recommended bait or lures based on conditions\",\n  \"strategy\": \"Fishing tips tailored to conditions\",\n  ${species && species !== 'None' ? '' : '\"recommended_species\": \"Suggested fish (common name only)\",'}\n  \"additional_notes\": \"Extra tips based on data (optional)\"\n}\nStrictly return JSON only, with no additional text or Markdown outside the JSON structure.\n`;\n\nexport const getSpeciesListFromAI = async (cityState) => {\n  const prompt = getSpeciesPrompt(cityState);\n  try {\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-4o-mini',\n        messages: [{ role: 'user', content: prompt }],\n      },\n      { headers: { 'Authorization': `Bearer ${OPENAI_API_KEY}` } }\n    );\n    const content = response.data.choices[0].message.content;\n    let parsed;\n    try {\n      parsed = JSON.parse(content);\n    } catch (e) {\n      const jsonMatch = content.match(/{[\\s\\S]*}/);\n      if (jsonMatch) parsed = JSON.parse(jsonMatch[0]);\n      else throw new Error('No valid JSON found');\n    }\n    return [...parsed.species, 'None'];\n  } catch (error) {\n    console.error('Species API Error:', error.message);\n    const fallback = cityState.includes('AL')\n      ? ['Largemouth Bass', 'Catfish', 'Crappie', 'Redfish', 'Bluegill']\n      : ['Largemouth Bass', 'Catfish', 'Rainbow Trout', 'Bluegill', 'Carp'];\n    return [...fallback, 'None'];\n  }\n};\n\nexport const getFishingAdvice = async (location, species, cityState, forecastData, waterData, speciesTempRange) => {\n  const currentDate = new Date().toLocaleString('default', { month: 'long', year: 'numeric' });\n  const prompt = getAdvicePrompt(location, species, cityState, currentDate, forecastData, waterData, speciesTempRange);\n  try {\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-4o-mini',\n        messages: [{ role: 'user', content: prompt }],\n        temperature: 0.3,\n      },\n      { headers: { 'Authorization': `Bearer ${OPENAI_API_KEY}` } }\n    );\n    const content = response.data.choices[0].message.content;\n    let parsed;\n    try {\n      parsed = JSON.parse(content);\n    } catch (e) {\n      const jsonMatch = content.match(/{[\\s\\S]*}/);\n      if (jsonMatch) parsed = JSON.parse(jsonMatch[0]);\n      else throw new Error('No valid JSON found');\n    }\n    return parsed;\n  } catch (error) {\n    console.error('Advice API Error:', error.message);\n    return {\n      bait: species && species !== 'None' ? 'Spinners or worms' : 'Worms',\n      strategy: 'Fish near cover or deep pools, adjusted for recent weather.',\n      ...(species && species !== 'None' ? {} : { recommended_species: 'Trout' }),\n      additional_notes: 'Fallback due to API error.'\n    };\n  }\n};\n\nexport const getSpeciesTempRange = async (species) => {\n  if (!species || species === 'None') return { min: 60, max: 80 };\n  const prompt = `\nProvide the optimal water temperature range in Fahrenheit for fishing the species \"${species}\" in the United States or Canada. Return the response in the following JSON format:\n{\n  \"species\": \"${species}\",\n  \"optimal_temp_range_f\": {\n    \"min\": <minimum temperature in Fahrenheit>,\n    \"max\": <maximum temperature in Fahrenheit>\n  }\n}\nUse current knowledge of recreational fishing. If the species is not valid or data is unavailable, return a default range of 60-80\u00b0F. Strictly return the response as JSON only, with no additional text or Markdown formatting outside the JSON structure.\n`;\n  try {\n    const response = await axios.post(\n      'https://api.openai.com/v1/chat/completions',\n      {\n        model: 'gpt-4o-mini',\n        messages: [{ role: 'user', content: prompt }],\n        temperature: 0.2,\n      },\n      { headers: { 'Authorization': `Bearer ${OPENAI_API_KEY}` } }\n    );\n    const content = response.data.choices[0].message.content;\n    let parsed;\n    try {\n      parsed = JSON.parse(content);\n    } catch (e) {\n      const jsonMatch = content.match(/{[\\s\\S]*}/);\n      if (jsonMatch) parsed = JSON.parse(jsonMatch[0]);\n      else throw new Error('No valid JSON found');\n    }\n    return parsed.optimal_temp_range_f;\n  } catch (error) {\n    console.error('Temp Range API Error:', error.message);\n    return { min: 60, max: 80 };\n  }\n};"
        },
        {
            "name": "app",
            "type": "directory",
            "children": [
                {
                    "name": "index.js",
                    "type": "file",
                    "size": 10188,
                    "modified": "Sun Mar 23 16:02:45 2025",
                    "content": "import React, { useState, useEffect, useCallback, useMemo } from 'react';\nimport { useRouter } from 'expo-router';\nimport {\n  View,\n  Text,\n  ImageBackground,\n  KeyboardAvoidingView,\n  Platform,\n  ScrollView,\n  TouchableOpacity,\n} from 'react-native';\nimport axios from 'axios';\nimport LocationToggle from '../components/LocationToggle';\nimport SpeciesPicker from '../components/SpeciesPicker';\nimport DateSelector from '../components/DateSelector';\nimport { getSpeciesListFromAI } from '../services/adviceService';\nimport { fetchLocationAndWeather, getCurrentLocation } from '../services/locationService';\nimport { GOOGLE_MAPS_API_KEY } from '@env';\nimport styles from '../styles/styles';\n\nexport default function HomeScreen() {\n  const router = useRouter();\n\n  const [useCurrentLocation, setUseCurrentLocation] = useState(false);\n  const [location, setLocation] = useState(null);\n  const [cityState, setCityState] = useState('');\n  const [manualCity, setManualCity] = useState('');\n  const [manualState, setManualState] = useState('');\n  const [species, setSpecies] = useState('');\n  const [customSpecies, setCustomSpecies] = useState('');\n  const [date, setDate] = useState(new Date());\n  const [speciesList, setSpeciesList] = useState([]);\n  const [weatherData, setWeatherData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isFetchingSpecies, setIsFetchingSpecies] = useState(false);\n  const [isFetchingLocation, setIsFetchingLocation] = useState(false); // New state\n  const [lastLocationFetch, setLastLocationFetch] = useState(null);\n\n  const debounce = (func, wait) => {\n    let timeout;\n    return (...args) => {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => func(...args), wait);\n    };\n  };\n\n  const initializeCurrentLocation = useCallback(async () => {\n    setIsFetchingLocation(true); // Start fetching location\n    if (lastLocationFetch) {\n      setLocation(lastLocationFetch);\n      try {\n        const response = await axios.get(\n          `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lastLocationFetch.coords.latitude},${lastLocationFetch.coords.longitude}&key=${GOOGLE_MAPS_API_KEY}`\n        );\n        if (response.data.results && response.data.results.length > 0) {\n          const addressComponents = response.data.results[0].address_components;\n          const city = addressComponents.find(comp => comp.types.includes('locality'))?.long_name || 'Unknown City';\n          const state = addressComponents.find(comp => comp.types.includes('administrative_area_level_1'))?.short_name || 'Unknown State';\n          const resolvedCityState = `${city}, ${state}`;\n          setCityState(resolvedCityState);\n          setManualCity(city);\n          setManualState(state);\n        } else {\n          throw new Error('No results found for geocoding');\n        }\n      } catch (error) {\n        console.error('Geocoding Error:', error.message);\n        setCityState('Location unavailable');\n        setManualCity('Unknown City');\n        setManualState('Unknown State');\n      }\n      setIsFetchingLocation(false); // Done fetching location\n      return;\n    }\n\n    const loc = await getCurrentLocation();\n    if (loc) {\n      setLocation(loc);\n      setLastLocationFetch(loc);\n      try {\n        const response = await axios.get(\n          `https://maps.googleapis.com/maps/api/geocode/json?latlng=${loc.coords.latitude},${loc.coords.longitude}&key=${GOOGLE_MAPS_API_KEY}`\n        );\n        if (response.data.results && response.data.results.length > 0) {\n          const addressComponents = response.data.results[0].address_components;\n          const city = addressComponents.find(comp => comp.types.includes('locality'))?.long_name || 'Unknown City';\n          const state = addressComponents.find(comp => comp.types.includes('administrative_area_level_1'))?.short_name || 'Unknown State';\n          const resolvedCityState = `${city}, ${state}`;\n          setCityState(resolvedCityState);\n          setManualCity(city);\n          setManualState(state);\n        } else {\n          throw new Error('No results found for geocoding');\n        }\n      } catch (error) {\n        console.error('Geocoding Error:', error.message);\n        setCityState('Location unavailable');\n        setManualCity('Unknown City');\n        setManualState('Unknown State');\n      }\n    } else {\n      console.error('Location permission denied or fetch failed');\n      setCityState('Location permission denied');\n    }\n    setIsFetchingLocation(false); // Done fetching location\n  }, [lastLocationFetch]);\n\n  const debouncedInitializeCurrentLocation = useMemo(\n    () => debounce(initializeCurrentLocation, 1000),\n    [initializeCurrentLocation]\n  );\n\n  useEffect(() => {\n    if (useCurrentLocation) {\n      debouncedInitializeCurrentLocation();\n    } else {\n      setLocation(null);\n      setLastLocationFetch(null);\n      setIsFetchingLocation(false); // Reset fetching state\n      if (!manualCity || !manualState) {\n        setCityState('');\n        setSpeciesList([]);\n        setWeatherData(null);\n        setCustomSpecies('');\n        setDate(new Date());\n      }\n    }\n  }, [useCurrentLocation, manualCity, manualState, debouncedInitializeCurrentLocation]);\n\n  const handleFetchSpecies = async () => {\n    setIsFetchingSpecies(true);\n    const targetCityState = useCurrentLocation ? cityState : `${manualCity}, ${manualState}`;\n    if (!targetCityState) {\n      console.error('No location specified');\n      setSpeciesList([]);\n      setIsFetchingSpecies(false);\n      return;\n    }\n    setCityState(targetCityState);\n\n    let loc = useCurrentLocation ? location : null;\n    if (!useCurrentLocation) {\n      const result = await fetchLocationAndWeather(false, targetCityState, null);\n      loc = result.loc;\n      setLocation(loc);\n      setLastLocationFetch(loc);\n    }\n\n    if (!loc?.coords) {\n      console.error('Failed to resolve location coordinates:', {\n        useCurrentLocation,\n        targetCityState,\n        location: loc,\n        manualCity,\n        manualState,\n      });\n      setSpeciesList([]);\n      setIsFetchingSpecies(false);\n      return;\n    }\n\n    try {\n      const weather = await fetchLocationAndWeather(useCurrentLocation, targetCityState, loc).weather;\n      setWeatherData(weather);\n      const speciesData = await getSpeciesListFromAI(targetCityState);\n      setSpeciesList([...speciesData, 'Other']);\n      setSpecies('');\n      setCustomSpecies('');\n    } catch (error) {\n      console.error('Fetch Error:', error.message);\n      setSpeciesList(await getSpeciesListFromAI('Location unavailable'));\n      setCityState('Location unavailable');\n      setWeatherData(null);\n      setCustomSpecies('');\n    }\n    setIsFetchingSpecies(false);\n  };\n\n  const handleSubmit = async () => {\n    if (isLoading || !location?.coords) return;\n    setIsLoading(true);\n    const finalSpecies = species === 'Other' ? customSpecies : species;\n    const localDate = new Date(date);\n    localDate.setHours(0, 0, 0, 0);\n    const formattedDate = localDate.toISOString().split('T')[0];\n\n    const simplifiedLocation = {\n      coords: {\n        latitude: location.coords.latitude,\n        longitude: location.coords.longitude,\n      },\n    };\n    const simplifiedWeatherData = weatherData ? { ...weatherData } : null;\n\n    try {\n      router.push({\n        pathname: '/results',\n        params: {\n          location: JSON.stringify(simplifiedLocation),\n          species: finalSpecies,\n          cityState,\n          weatherData: simplifiedWeatherData ? JSON.stringify(simplifiedWeatherData) : null,\n          date: formattedDate,\n        },\n      });\n    } catch (error) {\n      console.error('Navigation Error:', error.message);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <ImageBackground source={require('assets/angler-casting-reel-into-water.png')} style={styles.background}>\n      <KeyboardAvoidingView behavior={Platform.OS === 'ios' ? 'padding' : 'height'} style={styles.keyboardAvoidingContainer}>\n        <ScrollView style={styles.container} contentContainerStyle={styles.scrollContent}>\n          <View style={styles.content}>\n            <View style={styles.header}>\n              <Text style={styles.title}>Angler\u2019s Edge</Text>\n            </View>\n            <LocationToggle\n              useCurrentLocation={useCurrentLocation}\n              setUseCurrentLocation={setUseCurrentLocation}\n              cityState={cityState}\n              manualCity={manualCity}\n              manualState={manualState}\n              setManualCity={setManualCity}\n              setManualState={setManualState}\n              isFetchingSpecies={isFetchingSpecies}\n              isFetchingLocation={isFetchingLocation} // Pass new prop\n              handleFetchSpecies={handleFetchSpecies}\n            />\n            <SpeciesPicker\n              species={species}\n              setSpecies={setSpecies}\n              customSpecies={customSpecies}\n              setCustomSpecies={setCustomSpecies}\n              speciesList={speciesList}\n              isFetchingSpecies={isFetchingSpecies}\n            />\n            <DateSelector date={date} setDate={setDate} />\n            <View style={styles.buttonSection}>\n              <TouchableOpacity\n                style={[\n                  styles.customButton,\n                  (isLoading || speciesList.length === 0 || (species === 'Other' && !customSpecies) || !location?.coords) &&\n                    styles.disabledButton,\n                ]}\n                onPress={handleSubmit}\n                disabled={isLoading || speciesList.length === 0 || (species === 'Other' && !customSpecies) || !location?.coords}\n              >\n                <Text style={styles.buttonText}>{isLoading ? 'Loading...' : 'Get Fishing Tips'}</Text>\n              </TouchableOpacity>\n            </View>\n          </View>\n        </ScrollView>\n      </KeyboardAvoidingView>\n    </ImageBackground>\n  );\n}"
                },
                {
                    "name": "results.js",
                    "type": "file",
                    "size": 10388,
                    "modified": "Sun Mar 23 16:13:32 2025",
                    "content": "import React, { useState, useEffect, useMemo } from 'react';\nimport { useLocalSearchParams, useRouter } from 'expo-router';\nimport {\n  ScrollView,\n  View,\n  Text,\n  ImageBackground,\n  ActivityIndicator,\n  TouchableOpacity,\n} from 'react-native';\nimport AsyncStorage from '@react-native-async-storage/async-storage'; // Import AsyncStorage\nimport { fetchWeatherData } from '../services/weatherService';\nimport { fetchWaterData } from '../services/waterService';\nimport { getFishingAdvice, getSpeciesTempRange } from '../services/adviceService';\nimport { formatDate } from '../utils/dateUtils';\nimport styles from '../styles/styles';\n\nexport default function ResultsScreen() {\n  const router = useRouter();\n  const params = useLocalSearchParams();\n\n  const location = useMemo(() => {\n    try {\n      return params.location ? JSON.parse(params.location) : null;\n    } catch (error) {\n      console.error('Error parsing location param:', error.message);\n      return null;\n    }\n  }, [params.location]);\n\n  const weatherData = useMemo(() => {\n    try {\n      return params.weatherData ? JSON.parse(params.weatherData) : null;\n    } catch (error) {\n      console.error('Error parsing weatherData param:', error.message);\n      return null;\n    }\n  }, [params.weatherData]);\n\n  const { species, cityState, date } = params;\n\n  const [advice, setAdvice] = useState(null);\n  const [forecastData, setForecastData] = useState(null);\n  const [waterData, setWaterData] = useState(null);\n  const [tempRange, setTempRange] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  const retryRequest = async (fn, maxRetries = 3, delay = 1000) => { // Increased delay to 60 seconds\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        return await fn();\n      } catch (err) {\n        if (err.response?.status === 429 && i < maxRetries - 1) {\n          const waitTime = delay * Math.pow(2, i);\n          console.warn(`Rate limit hit, retrying in ${waitTime}ms... (Attempt ${i + 1}/${maxRetries})`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        } else {\n          throw err;\n        }\n      }\n    }\n  };\n\n  // Cache weather data in AsyncStorage\n  const cacheWeatherData = async (key, data) => {\n    try {\n      await AsyncStorage.setItem(key, JSON.stringify(data));\n    } catch (err) {\n      console.error('Error caching weather data:', err.message);\n    }\n  };\n\n  const getCachedWeatherData = async (key) => {\n    try {\n      const cached = await AsyncStorage.getItem(key);\n      return cached ? JSON.parse(cached) : null;\n    } catch (err) {\n      console.error('Error retrieving cached weather data:', err.message);\n      return null;\n    }\n  };\n\n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      try {\n        if (!location?.coords?.latitude || !location?.coords?.longitude) {\n          throw new Error('Location coordinates are missing.');\n        }\n\n        const lat = location.coords.latitude;\n        const lon = location.coords.longitude;\n\n        let forecast;\n        // Create a cache key based on location and date\n        const weatherCacheKey = `weather_${lat}_${lon}_${date}`;\n        const cachedForecast = await getCachedWeatherData(weatherCacheKey);\n\n        if (cachedForecast) {\n          forecast = cachedForecast;\n          setForecastData(forecast);\n        } else if (weatherData) {\n          forecast = { forecastMetrics: weatherData, dailyForecasts: [] };\n          setForecastData(forecast);\n          await cacheWeatherData(weatherCacheKey, forecast);\n        } else {\n          try {\n            forecast = await retryRequest(() => fetchWeatherData(lat, lon, date));\n            setForecastData(forecast);\n            await cacheWeatherData(weatherCacheKey, forecast);\n          } catch (err) {\n            throw new Error(`Weather Data Fetch Failed: ${err.message}`);\n          }\n        }\n\n        let water;\n        try {\n          water = await retryRequest(() => fetchWaterData(lat, lon, date, forecast.dailyForecasts || []));\n          setWaterData(water);\n        } catch (err) {\n          throw new Error(`Water Data Fetch Failed: ${err.message}`);\n        }\n\n        let speciesRange;\n        try {\n          speciesRange = await retryRequest(() => getSpeciesTempRange(species));\n          setTempRange(speciesRange);\n        } catch (err) {\n          throw new Error(`Species Temp Range Fetch Failed: ${err.message}`);\n        }\n\n        let adviceResult;\n        try {\n          adviceResult = await retryRequest(() =>\n            getFishingAdvice(location, species, cityState, forecast.forecastMetrics, water, speciesRange)\n          );\n          setAdvice(adviceResult);\n        } catch (err) {\n          throw new Error(`Fishing Advice Fetch Failed: ${err.message}`);\n        }\n\n        const rating = calculateFishingScore(forecast.forecastMetrics, water, speciesRange);\n        setForecastData({ ...forecast.forecastMetrics, rating });\n      } catch (err) {\n        console.error('Results Data Error:', err.message);\n        setError(err.message);\n        setAdvice(null);\n        setForecastData(null);\n        setWaterData(null);\n        setTempRange(null);\n      }\n      setLoading(false);\n    };\n\n    fetchData();\n  }, [location, species, cityState, weatherData, date]);\n\n  const calculateFishingScore = (forecastMetrics, waterMetrics, speciesTempRange) => {\n    let score = 50;\n    if (waterMetrics.waterTempF && speciesTempRange) {\n      if (waterMetrics.waterTempF >= speciesTempRange.min && waterMetrics.waterTempF <= speciesTempRange.max) score += 20;\n      else if (waterMetrics.waterTempF < speciesTempRange.min - 10 || waterMetrics.waterTempF > speciesTempRange.max + 10) score -= 10;\n    }\n    if (forecastMetrics.lowTempF >= 59 && forecastMetrics.highTempF <= 80) score += 10;\n    else if (forecastMetrics.highTempF - forecastMetrics.lowTempF > 20) score -= 5;\n    if (forecastMetrics.totalPrecipIn > 0 && forecastMetrics.totalPrecipIn <= 0.1) score += 5;\n    else if (forecastMetrics.totalPrecipIn > 0.5) score -= 5;\n    if (forecastMetrics.avgWindMph >= 3 && forecastMetrics.avgWindMph <= 10) score += 5;\n    else if (forecastMetrics.avgWindMph > 15) score -= 10;\n    if (forecastMetrics.windDeg >= 45 && forecastMetrics.windDeg <= 135) score += 3;\n    if (forecastMetrics.pressureHpa < 1013) score += 5;\n    if (typeof forecastMetrics.moonPhase === 'number') {\n      if (forecastMetrics.moonPhase === 0 || forecastMetrics.moonPhase === 0.5) score += 10;\n      else if (forecastMetrics.moonPhase === 0.25 || forecastMetrics.moonPhase === 0.75) score += 5;\n      else if (forecastMetrics.moonPhase > 0 && forecastMetrics.moonPhase < 1) score += 3;\n    }\n    if (waterMetrics.gageHeightFt !== null) score += 5;\n\n    return Math.round((Math.max(0, Math.min(100, score)) / 100) * 5) || 1;\n  };\n\n  if (loading) {\n    return (\n      <ImageBackground source={require('assets/angler-casting-reel-into-water.png')} style={styles.background}>\n        <View style={styles.loadingContainer}>\n          <ActivityIndicator size=\"large\" color=\"#fff\" />\n        </View>\n      </ImageBackground>\n    );\n  }\n\n  const parsedDate = new Date(`${date}T00:00:00`);\n\n  return (\n    <ImageBackground source={require('assets/angler-casting-reel-into-water.png')} style={styles.background}>\n      <ScrollView style={styles.container}>\n        <View style={styles.header}>\n          <Text style={styles.title}>Fishing Advice for {cityState} - {species || 'Unknown Species'}</Text>\n        </View>\n        <View style={styles.forecastSection}>\n          {forecastData ? (\n            <View style={styles.forecastCard}>\n              <Text style={styles.forecastField}><Text style={styles.label}>Date: </Text>{formatDate(date)}</Text>\n              <Text style={styles.forecastField}><Text style={styles.label}>Temperature: </Text>{forecastData.lowTempF}\u2013{forecastData.highTempF}\u00b0F</Text>\n              <Text style={styles.forecastField}><Text style={styles.label}>Precipitation: </Text>{forecastData.totalPrecipIn} in</Text>\n              <Text style={styles.forecastField}><Text style={styles.label}>Wind Speed: </Text>{forecastData.avgWindMph} mph</Text>\n              {waterData?.waterTempF && (\n                <Text style={styles.forecastField}><Text style={styles.label}>Water Temp: </Text>{waterData.waterTempF.toFixed(1)}\u00b0F {parsedDate > new Date() ? '(forecasted)' : ''}</Text>\n              )}\n              {waterData?.gageHeightFt && (\n                <Text style={styles.forecastField}><Text style={styles.label}>Water Level: </Text>{waterData.gageHeightFt.toFixed(2)} ft {parsedDate > new Date() ? '(forecasted)' : ''}</Text>\n              )}\n              <Text style={styles.forecastField}><Text style={styles.label}>Fishing Conditions: </Text>{'\u2605'.repeat(forecastData.rating)}{'\u2606'.repeat(5 - forecastData.rating)}</Text>\n            </View>\n          ) : error ? (\n            <Text style={styles.errorText}>Error: {error}</Text>\n          ) : (\n            <Text style={styles.errorText}>Unable to load forecast data.</Text>\n          )}\n        </View>\n        <View style={styles.content}>\n          <View style={styles.adviceSection}>\n            <View style={styles.adviceCard}>\n              {advice && (\n                <>\n                  <Text style={styles.field}><Text style={styles.label}>Bait: </Text><Text>{advice.bait || 'Not specified'}</Text></Text>\n                  <Text style={styles.field}><Text style={styles.label}>Strategy: </Text><Text>{advice.strategy || 'Not specified'}</Text></Text>\n                  {advice.additional_notes && (\n                    <Text style={styles.field}><Text style={styles.label}>Additional Notes: </Text><Text>{advice.additional_notes}</Text></Text>\n                  )}\n                </>\n              )}\n            </View>\n          </View>\n          <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>\n            <Text style={styles.buttonText}>Back to Home</Text>\n          </TouchableOpacity>\n        </View>\n      </ScrollView>\n    </ImageBackground>\n  );\n}"
                }
            ]
        },
        {
            "name": "Archive",
            "type": "directory",
            "children": [
                {
                    "name": "App.js",
                    "type": "file",
                    "size": 656,
                    "modified": "Sun Mar 23 14:56:46 2025",
                    "content": "import React from 'react';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { createStackNavigator } from '@react-navigation/stack';\nimport HomeScreen from '../app/HomeScreen';\nimport ResultsScreen from '../app/ResultsScreen';\n\nconst Stack = createStackNavigator();\n\nexport default function App() {\n  return (\n    <NavigationContainer>\n      <Stack.Navigator initialRouteName=\"Home\">\n        <Stack.Screen name=\"Home\" component={HomeScreen} options={{ headerShown: false }} />\n        <Stack.Screen name=\"Results\" component={ResultsScreen} options={{ headerShown: false }} />\n      </Stack.Navigator>\n    </NavigationContainer>\n  );\n}"
                }
            ]
        },
        {
            "name": "components",
            "type": "directory",
            "children": [
                {
                    "name": "DateSelector.js",
                    "type": "file",
                    "size": 1581,
                    "modified": "Sun Mar 23 15:51:57 2025",
                    "content": "import React, { useState } from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport DateTimePicker from '@react-native-community/datetimepicker';\nimport styles from 'styles/styles';\nimport { Platform } from 'react-native';\n\nconst DateSelector = ({ date, setDate }) => {\n  const [showDatePicker, setShowDatePicker] = useState(false);\n\n  const onDateChange = (event, selectedDate) => {\n    const currentDate = selectedDate || date;\n    // Normalize to midnight\n    const normalizedDate = new Date(currentDate);\n    normalizedDate.setHours(0, 0, 0, 0);\n    console.log('Selected Date (DateSelector):', normalizedDate.toISOString().split('T')[0]);\n    setShowDatePicker(false);\n    setDate(normalizedDate);\n  };\n\n  return (\n    <View style={styles.dateSection}>\n      <Text style={styles.label}>Select Fishing Trip Date:</Text>\n      <TouchableOpacity style={styles.dateButton} onPress={() => setShowDatePicker(true)}>\n        <Text style={styles.buttonText}>Selected Date: {date.toLocaleDateString()}</Text>\n      </TouchableOpacity>\n      {showDatePicker && (\n        <View style={styles.pickerOverlay}>\n          <DateTimePicker\n            value={date}\n            mode=\"date\"\n            display={Platform.OS === 'ios' ? 'inline' : 'default'}\n            onChange={onDateChange}\n            minimumDate={new Date()}\n            maximumDate={new Date(new Date().setDate(new Date().getDate() + 7))}\n            textColor=\"#fff\"\n          />\n        </View>\n      )}\n    </View>\n  );\n};\n\nexport default DateSelector;"
                },
                {
                    "name": "FishingTips.js",
                    "type": "file",
                    "size": 0,
                    "modified": "Fri Feb 21 15:22:40 2025",
                    "content": ""
                },
                {
                    "name": "LocationToggle.js",
                    "type": "file",
                    "size": 2256,
                    "modified": "Sun Mar 30 00:02:10 2025",
                    "content": "import React from 'react';\nimport { View, Text, Switch, TextInput, TouchableOpacity } from 'react-native';\nimport styles from 'styles/styles';\n\nconst LocationToggle = ({\n  useCurrentLocation,\n  setUseCurrentLocation,\n  cityState,\n  manualCity,\n  manualState,\n  setManualCity,\n  setManualState,\n  isFetchingSpecies,\n  isFetchingLocation, // New prop\n  handleFetchSpecies,\n}) => {\n  const handleToggle = () => {\n    setUseCurrentLocation(!useCurrentLocation);\n    if (useCurrentLocation) {\n      setManualCity('');\n      setManualState('');\n    }\n  };\n\n  return (\n    <View style={styles.locationSection}>\n      <View style={styles.toggleContainer}>\n        <Text style={styles.toggleLabel}>Use Current Location:</Text>\n        <Switch\n          onValueChange={handleToggle}\n          value={useCurrentLocation}\n          trackColor={{ false: '#00CED1', true: '#00CED1' }}\n        />\n      </View>\n      {useCurrentLocation ? (\n        <Text style={styles.locationText}>\n          {cityState || 'Fetching location...'}\n        </Text>\n      ) : (\n        <View style={styles.manualLocationContainer}>\n          <TextInput\n            style={styles.input}\n            placeholder=\"City (e.g., Citronelle)\"\n            placeholderTextColor=\"#999\"\n            value={manualCity}\n            onChangeText={setManualCity}\n          />\n          <TextInput\n            style={styles.input}\n            placeholder=\"State/Province (e.g., AL)\"\n            placeholderTextColor=\"#999\"\n            value={manualState}\n            onChangeText={setManualState}\n          />\n        </View>\n      )}\n      <TouchableOpacity\n        style={[\n          styles.customButton,\n          (isFetchingSpecies || isFetchingLocation || (!useCurrentLocation && (!manualCity || !manualState))) && styles.disabledButton,\n        ]}\n        onPress={handleFetchSpecies}\n        disabled={isFetchingSpecies || isFetchingLocation || (!useCurrentLocation && (!manualCity || !manualState))}\n      >\n        <Text style={styles.buttonText}>\n          {isFetchingSpecies || isFetchingLocation ? 'Loading...' : 'Get Species'}\n        </Text>\n      </TouchableOpacity>\n    </View>\n  );\n};\n\nexport default LocationToggle;"
                },
                {
                    "name": "SettingsScreen.js",
                    "type": "file",
                    "size": 0,
                    "modified": "Fri Feb 21 15:22:23 2025",
                    "content": ""
                },
                {
                    "name": "SpeciesPicker.js",
                    "type": "file",
                    "size": 1372,
                    "modified": "Sun Mar 23 11:32:04 2025",
                    "content": "import React from 'react';\nimport { View, Text, TextInput, ActivityIndicator } from 'react-native';\nimport { Picker } from '@react-native-picker/picker';\nimport styles from '../styles/styles'; // Updated path\n\nconst SpeciesPicker = ({\n  species,\n  setSpecies,\n  customSpecies,\n  setCustomSpecies,\n  speciesList,\n  isFetchingSpecies\n}) => (\n  <View style={styles.speciesSection}>\n    {isFetchingSpecies ? (\n      <ActivityIndicator size=\"small\" color=\"#fff\" />\n    ) : speciesList.length === 0 ? (\n      <Text style={styles.placeholder}>Select location and press <Text style={styles.getSpecies}>Get Species</Text> to load options.</Text>\n    ) : (\n      <>\n        <Text style={styles.label}>Select Target Species:</Text>\n        <Picker\n          selectedValue={species}\n          onValueChange={setSpecies}\n          style={styles.picker}\n        >\n          {speciesList.map((sp) => (\n            <Picker.Item key={sp} label={sp} value={sp} color=\"#333\" />\n          ))}\n        </Picker>\n        {species === 'Other' && (\n          <TextInput\n            style={styles.input}\n            placeholder=\"Enter custom species\"\n            value={customSpecies}\n            onChangeText={setCustomSpecies}\n            placeholderTextColor=\"#888\"\n          />\n        )}\n      </>\n    )}\n  </View>\n);\n\nexport default SpeciesPicker;"
                }
            ]
        },
        {
            "name": "services",
            "type": "directory",
            "children": [
                {
                    "name": "adviceService.js",
                    "type": "file",
                    "size": 237,
                    "modified": "Sun Mar 23 11:30:01 2025",
                    "content": "// Import the original functions from api.js\nimport { getSpeciesListFromAI, getFishingAdvice, getSpeciesTempRange } from 'api';\n\n// Export the original functions\nexport { getSpeciesListFromAI, getFishingAdvice, getSpeciesTempRange };"
                },
                {
                    "name": "locationService.js",
                    "type": "file",
                    "size": 2609,
                    "modified": "Sun Mar 23 10:29:22 2025",
                    "content": "import * as Location from 'expo-location';\nimport axios from 'axios';\nimport { GOOGLE_MAPS_API_KEY } from '@env';\n\nexport const fetchLocationAndWeather = async (useCurrentLocation, targetCityState, currentLocation) => {\n  let loc = useCurrentLocation ? currentLocation : null;\n  let weather = null;\n\n  if (useCurrentLocation && !loc) {\n    loc = await getCurrentLocation();\n    if (!loc) return { loc: null, weather: null };\n  } else if (!useCurrentLocation) {\n    try {\n      const response = await axios.get(\n        `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(targetCityState)}&key=${GOOGLE_MAPS_API_KEY}`\n      );\n      if (response.data.results && response.data.results.length > 0) {\n        const { lat, lng } = response.data.results[0].geometry.location;\n        loc = { coords: { latitude: lat, longitude: lng } };\n      } else {\n        throw new Error('No geocoding results found');\n      }\n    } catch (error) {\n      console.error('Geocoding Error:', error.message);\n      return { loc: null, weather: null };\n    }\n  }\n\n  if (loc) {\n    try {\n      const endDate = new Date().toISOString().split('T')[0];\n      const startDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n      const weatherResponse = await axios.get(\n        `https://archive-api.open-meteo.com/v1/archive?latitude=${loc.coords.latitude}&longitude=${loc.coords.longitude}&start_date=${startDate}&end_date=${endDate}&hourly=temperature_2m,precipitation,wind_speed_10m`\n      );\n      const weatherData = weatherResponse.data.hourly;\n      weather = {\n        avgTemp: (weatherData.temperature_2m.reduce((a, b) => a + b, 0) / weatherData.temperature_2m.length).toFixed(1),\n        totalPrecip: weatherData.precipitation.reduce((a, b) => a + b, 0).toFixed(1),\n        avgWind: (weatherData.wind_speed_10m.reduce((a, b) => a + b, 0) / weatherData.wind_speed_10m.length).toFixed(1)\n      };\n    } catch (error) {\n      console.error('Weather Fetch Error:', error.message);\n      weather = null;\n    }\n  }\n\n  return { loc, weather };\n};\n\nexport const getCurrentLocation = async () => {\n  let { status } = await Location.requestForegroundPermissionsAsync();\n  if (status !== 'granted') {\n    console.error('Location permission denied');\n    return null;\n  }\n  try {\n    const loc = await Location.getCurrentPositionAsync({});\n    console.log('Current location fetched:', loc.coords);\n    return loc;\n  } catch (error) {\n    console.error('Location fetch error:', error.message);\n    return null;\n  }\n};"
                },
                {
                    "name": "waterService.js",
                    "type": "file",
                    "size": 2987,
                    "modified": "Sat Feb 22 22:28:13 2025",
                    "content": "import axios from 'axios';\n\nexport const fetchWaterData = async (lat, lon, date, dailyForecasts) => {\n  const westLon = (lon - 0.5).toFixed(6);\n  const southLat = (lat - 0.5).toFixed(6);\n  const eastLon = (lon + 0.5).toFixed(6);\n  const northLat = (lat + 0.5).toFixed(6);\n  const bBox = `${westLon},${southLat},${eastLon},${northLat}`;\n  const usgsUrl = `https://waterservices.usgs.gov/nwis/dv/`;\n\n  const nowUtc = new Date();\n  const todayLocal = new Date(nowUtc.getTime()); // Simplified, assumes CST for now\n  todayLocal.setHours(0, 0, 0, 0);\n  const selectedLocal = new Date(date);\n  selectedLocal.setHours(0, 0, 0, 0);\n\n  let waterMetrics = { waterTempF: null, gageHeightFt: null };\n  const lastAvailableDate = todayLocal.toISOString().split('T')[0];\n  const usgsParams = {\n    format: 'json',\n    bBox: bBox,\n    parameterCd: '00010,00065',\n    startDT: lastAvailableDate,\n    endDT: lastAvailableDate\n  };\n  console.log('Fetching USGS baseline:', `${usgsUrl}?${new URLSearchParams(usgsParams).toString()}`);\n  const usgsResponse = await axios.get(usgsUrl, { params: usgsParams });\n  const timeSeries = usgsResponse.data.value.timeSeries;\n  if (timeSeries.length > 0) {\n    const tempSeries = timeSeries.find(ts => ts.variable.variableCode[0].value === '00010');\n    const levelSeries = timeSeries.find(ts => ts.variable.variableCode[0].value === '00065');\n    if (tempSeries?.values[0]?.value[0]?.value) {\n      waterMetrics.waterTempF = (parseFloat(tempSeries.values[0].value[0].value) * 9 / 5) + 32;\n    }\n    if (levelSeries?.values[0]?.value[0]?.value) {\n      waterMetrics.gageHeightFt = parseFloat(levelSeries.values[0].value[0].value);\n    }\n  }\n\n  const daysAhead = Math.ceil((selectedLocal - todayLocal) / (1000 * 60 * 60 * 24));\n  if (daysAhead > 0) {\n    const forecastWater = forecastWaterData(waterMetrics.waterTempF, waterMetrics.gageHeightFt, daysAhead, dailyForecasts);\n    waterMetrics = forecastWater[daysAhead - 1];\n    console.log('Forecasted water data for', date, ':', waterMetrics);\n  }\n\n  return waterMetrics;\n};\n\nconst forecastWaterData = (baseWaterTemp, baseGageHeight, forecastDays, dailyForecasts) => {\n  let waterTemp = baseWaterTemp || 60;\n  let gageHeight = baseGageHeight || 2;\n  const forecasted = [];\n\n  const k = 0.1;\n  const r = 0.5;\n  const t = 0.5;\n\n  for (let i = 0; i < forecastDays; i++) {\n    const day = dailyForecasts[i] || dailyForecasts[dailyForecasts.length - 1];\n    const avgAirTemp = (day.temp.min + day.temp.max) / 2;\n    const precip = day.rain || 0;\n\n    waterTemp = waterTemp + k * (avgAirTemp - waterTemp);\n    if (waterTemp < 32) waterTemp = 32;\n\n    const tidalTime = i * 24;\n    const tidalEffect = t * Math.sin((2 * Math.PI / 12.42) * tidalTime);\n    gageHeight = gageHeight + r * precip + tidalEffect;\n    if (gageHeight < 0) gageHeight = 0;\n\n    forecasted.push({ waterTempF: waterTemp, gageHeightFt: gageHeight });\n  }\n\n  return forecasted;\n};"
                },
                {
                    "name": "weatherService.js",
                    "type": "file",
                    "size": 2710,
                    "modified": "Sun Mar 23 10:06:30 2025",
                    "content": "import axios from 'axios';\nimport { OPEN_WEATHER_MAP_API_KEY } from '@env';\nimport { validateDate } from '../utils/dateUtils';\n\nconst getMoonPhaseName = (moonPhase) => {\n  if (moonPhase === undefined || moonPhase === null || moonPhase === 'Not available') return 'Unknown';\n  // Moon phase values (0 to 1) from OpenWeather API:\n  // 0 = New Moon, 0.25 = First Quarter, 0.5 = Full Moon, 0.75 = Last Quarter\n  if (moonPhase === 0) return 'New Moon';\n  if (moonPhase === 0.25) return 'First Quarter';\n  if (moonPhase === 0.5) return 'Full Moon';\n  if (moonPhase === 0.75) return 'Last Quarter';\n  if (moonPhase > 0 && moonPhase < 0.25) return 'Waxing Crescent'; // 0 < phase < 0.25\n  if (moonPhase > 0.25 && moonPhase < 0.5) return 'Waxing Gibbous'; // 0.25 < phase < 0.5\n  if (moonPhase > 0.5 && moonPhase < 0.75) return 'Waning Gibbous'; // 0.5 < phase < 0.75\n  if (moonPhase > 0.75 && moonPhase < 1) return 'Waning Crescent'; // 0.75 < phase < 1\n  return 'Unknown'; // Fallback for unexpected values\n};\n\nexport const fetchWeatherData = async (lat, lon, date) => {\n  const weatherUrl = `https://api.openweathermap.org/data/3.0/onecall?lat=${lat}&lon=${lon}&exclude=minutely,hourly,alerts&units=imperial&appid=${OPEN_WEATHER_MAP_API_KEY}`;\n  const response = await axios.get(weatherUrl);\n\n  // Use device system time directly\n  const todayLocal = new Date(); // Current local date/time (e.g., CST)\n  todayLocal.setHours(0, 0, 0, 0); // Set to midnight local time\n\n  // Parse date as local midnight using device system time\n  const selectedLocal = new Date(`${date}T00:00:00`); // Explicitly parse as local midnight\n  selectedLocal.setHours(0, 0, 0, 0); // Ensure midnight local time\n\n  const maxDateLocal = new Date(todayLocal);\n  maxDateLocal.setDate(todayLocal.getDate() + 7); // 7 days from today\n\n  if (!validateDate(selectedLocal, todayLocal, maxDateLocal)) {\n    throw new Error('Date must be within 7 days from today.');\n  }\n\n  const dailyForecasts = response.data.daily;\n  let dailyForecast = dailyForecasts.find(d => \n    new Date(d.dt * 1000).toISOString().split('T')[0] === date\n  );\n  if (!dailyForecast) {\n    dailyForecast = dailyForecasts[dailyForecasts.length - 1];\n  }\n\n  const moonPhase = getMoonPhaseName(dailyForecast.moon_phase); // Convert decimal to name\n  const forecastMetrics = {\n    lowTempF: dailyForecast.temp.min,\n    highTempF: dailyForecast.temp.max,\n    totalPrecipIn: dailyForecast.rain || 0,\n    avgWindMph: dailyForecast.wind_speed,\n    windDeg: dailyForecast.wind_deg,\n    pressureHpa: dailyForecast.pressure,\n    moonPhase: moonPhase // Store as moon phase name\n  };\n\n  return { forecastMetrics, dailyForecasts };\n};"
                }
            ]
        },
        {
            "name": "styles",
            "type": "directory",
            "children": [
                {
                    "name": "styles.js",
                    "type": "file",
                    "size": 4528,
                    "modified": "Sun Mar 30 00:03:22 2025",
                    "content": "import { StyleSheet } from 'react-native';\n\nexport default StyleSheet.create({\n  background: { flex: 1, width: '100%', height: '100%' },\n  keyboardAvoidingContainer: { flex: 1 },\n  container: { flex: 1, backgroundColor: 'rgba(0, 0, 0, 0.5)' },\n  scrollContent: { flexGrow: 1 },\n  content: { paddingVertical: 20 },\n  header: { paddingHorizontal: 30, alignItems: 'center', marginBlock: 50 },\n  title: { fontSize: 28, fontWeight: 'bold', color: '#fff', textShadowColor: '#000', textShadowOffset: { width: 1, height: 1 }, textShadowRadius: 2 },\n  \n  toggleContainer: { \n    flexDirection: 'row', \n    alignItems: 'center', \n    alignSelf: 'center', \n    marginBottom: 25, \n    width: \"auto\", \n    backgroundColor: 'rgba(255, 255, 255, 0.8)', \n    paddingInline: 20, \n    paddingBlock: 5, \n    borderRadius: 8,\n    textAlignVertical: 'center',\n  },\n\n  toggleLabel: { fontSize: 16, color: '#333', marginRight: 10 },\n  locationSection: { paddingHorizontal: 30, marginBottom: 20, alignItems: 'center' },\n  locationText: { fontSize: 16, color: '#fff', textAlign: 'center', marginBottom: 10, textShadowColor: '#000', textShadowOffset: { width: 1, height: 1 }, textShadowRadius: 2 },\n  \n  input: { \n    height: 40, \n    borderColor: '#ccc', \n    borderWidth: 1, \n    borderRadius: 8, \n    paddingHorizontal: 10, \n    marginBottom: 10,\n    backgroundColor: 'rgba(255, 255, 255, 0.9)', \n    color: '#333', \n    width: '100%' \n  },\n\n  manualLocationContainer: {\n    alignItems: 'center',\n    width: '100%',\n    marginBottom: '20',\n  },\n\n  dateSection: { paddingHorizontal: 30, marginVertical: 50, alignItems: 'center' },\n  dateButton: { backgroundColor: '#00CED1', paddingVertical: 12, paddingHorizontal: 20, borderRadius: 12, marginBottom: 20, alignItems: 'center', shadowColor: '#000', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.3, shadowRadius: 4, elevation: 5 },\n  pickerOverlay: { backgroundColor: 'rgba(255, 255, 255, 0.66)', borderRadius: 8, padding: 10, marginBottom: 20, shadowColor: '#000', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.2, shadowRadius: 4, elevation: 3 },\n  speciesSection: { paddingHorizontal: 30, marginVertical: 50 },\n  \n  label: { \n    fontSize: 18, \n    color: '#00CED1',  \n    fontWeight: 700,\n    alignItems: 'center',\n    marginBottom: 10,\n    textAlign: 'center'\n  },\n  \n  picker: { height: 200, width: '100%', backgroundColor: 'rgba(255, 255, 255, 0.9)', borderRadius: 8, textAlignVertical: 'center' },\n  placeholder: { fontSize: 16, color: '#fff', marginVertical: 20, textAlign: 'center', textShadowColor: '#000', textShadowOffset: { width: 1, height: 1 }, textShadowRadius: 2 },\n  getSpecies: { fontWeight: '700' },\n  buttonSection: { paddingHorizontal: 30, alignItems: 'center', marginBottom: 20 },\n  customButton: { backgroundColor: '#00CED1', paddingVertical: 12, paddingHorizontal: 20, borderRadius: 12, alignItems: 'center', justifyContent: 'center', shadowColor: '#000', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.3, shadowRadius: 4, elevation: 5, width: '100%' },\n  disabledButton: { backgroundColor: '#A9A9A9', opacity: 0.7 },\n  buttonText: { fontSize: 16, color: '#fff', fontWeight: '600' },\n  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: 'rgba(0, 0, 0, 0.5)' },\n  forecastSection: { paddingHorizontal: 30, marginTop: 20 },\n  adviceSection: { paddingHorizontal: 30, marginVertical: 20 },\n  forecastCard: { backgroundColor: 'rgba(255, 255, 255, 0.9)', borderRadius: 12, padding: 15, shadowColor: '#000', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.1, shadowRadius: 4, elevation: 3, width: '100%' },\n  adviceCard: { backgroundColor: 'rgba(255, 255, 255, 0.9)', borderRadius: 12, padding: 15, shadowColor: '#000', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.1, shadowRadius: 4, elevation: 3, marginBottom: 20 },\n  field: { fontSize: 16, color: '#333', lineHeight: 24, marginBottom: 10 },\n  forecastField: { fontSize: 16, color: '#333', lineHeight: 24, marginBottom: 10 },\n  errorText: { fontSize: 16, color: '#fff', textAlign: 'center', textShadowColor: '#000', textShadowOffset: { width: 1, height: 1 }, textShadowRadius: 2 },\n  backButton: { backgroundColor: '#00CED1', paddingVertical: 12, paddingHorizontal: 20, borderRadius: 12, alignItems: 'center', shadowColor: '#000', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.3, shadowRadius: 4, elevation: 5, marginBottom: 20, marginHorizontal: 30 },\n});"
                }
            ]
        },
        {
            "name": "utils",
            "type": "directory",
            "children": [
                {
                    "name": "dateUtils.js",
                    "type": "file",
                    "size": 678,
                    "modified": "Sun Feb 23 00:29:00 2025",
                    "content": "export const formatDate = (dateString) => {\n    const dateObj = new Date(`${dateString}T00:00:00`); // Force local parsing for midnight\n    const dayOfWeek = dateObj.toLocaleDateString('en-US', { weekday: 'long', timeZone: 'America/Chicago' }); // Explicitly use CST\n    const monthName = dateObj.toLocaleDateString('en-US', { month: 'long', timeZone: 'America/Chicago' });\n    const day = dateObj.getDate();\n    const year = dateObj.getFullYear();\n    return `${dayOfWeek} ${monthName} ${day}, ${year}`;\n  };\n  \n  export const validateDate = (selectedLocal, todayLocal, maxDateLocal) => {\n    return selectedLocal >= todayLocal && selectedLocal <= maxDateLocal;\n  };"
                }
            ]
        }
    ]
}